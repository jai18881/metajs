---
layout: page
class: homepage
permalink: /features/
order: 2

title: "Features"
heading: "Features"
description: "Overview of MetaJS features."
icon: features
---

<div class="column-a1">
	
	<h2 class="huge blue clr-icon clr-text clr-border">{% include icons/dev-code.svg %} DOM Templates</h2>
	<p>MetaJS provides templating engine which manipulates directly with DOM. This way needs no re-rendering so it is efficient and provides high performance.</p>

	<h3 class="mini">DOM based</h3>
	<p>No re-rendering and no browser re-parsing provides high performance and flexibility compared to other traditional string-based engines.</p>

	<h3 class="mini">Data binding</h3>
	<p>Templating engine provides data binding, conditions and loops.</p>
	<ul>
		<li>item is <strong>added to array</strong> -&gt; new dom <strong>node appended</strong></li>
		<li>item is <strong>removed from array</strong> -&gt; dom <strong>node removed</strong></li>
		<li>item <strong>index changed</strong> -&gt; dom node  <strong>moved</strong></li>
		<li>item <strong>data changed</strong> -&gt; <strong>binding updated</strong> = no flickering</li>
	</ul>

	<h3 class="mini">Rule based</h3>
	<p>Template logic is defined by rules (processing functions) and provides flexible interface for non-standard usage.</p>

</div>

<div class="column-a2">

	<h2 class="huge orange clr-icon clr-text clr-border">{% include icons/dev-screen.svg %} Views</h2>
	<p>MetaJS provides <strong>View</strong> component which is wrapper for templates and adds view-logic and other features such as automatic event-binding and name-based access.</p>

	<h3 class="mini">Template definition &amp; view logic</h3>
	<p>Views are extending native html <strong>template</strong> tag and provides its instacing. View wraps MetaJS templating engine and provides nice interface for view logic definition.</p>

	<h3 class="mini">Event binding</h3>
	<p>Views provides automatic event binding when template data changed. So you define event bindings once and when nodes are added or changed their events are automatically binded.</p>

	<h3 class="mini">Global registry</h3>
	<p>Views can be defined only once and can be added to registry so other components can access it via name reference.</p>

</div>

<div class="clear"></div>

<div class="column-w">

	<h2 class="huge purple clr-icon clr-text clr-border">{% include icons/app.svg %} Fragments &amp; Activities</h2>
	<p>MetaJS provides <strong>Fragment</strong> and <strong>Activity</strong> components which are representing reusable UI building blocks.</p>
	<p>Fragments and activities also supports <strong>ShadowDOM</strong> for convenient styling and resource distribution.</p>

	<div class="highlight-box">
		<div class="column-a1 friendly">
			<h3 class="mini">Fragment</h3>
			<p>
				Fragment represents basic reusable component such as:<br />
				<strong>header</strong>, <strong>toolbar</strong>, <strong>search-box</strong>, <strong>list-view</strong>, etc...
			</p>
		</div>

		<div class="column-a2 friendly">
			<h3 class="mini">Activity</h3>
			<p>
				Activity represents specific use-case component such as:<br />
				<strong>customers list</strong>, <strong>customer detail</strong>, <strong>user account</strong>, etc...
			</p>
		</div>

		<div class="clear"></div>
	</div>

	<div class="column-a1 padded">
		<h3 class="mini">Component logic</h3>
		<p>Fragments uses <strong>Views</strong> and wraps its view-logic and event binding in a friendly way.</p>

		<h3 class="mini">Data model</h3>
		<p>Fragments provides data model object which is automatically binded to view.</p>

		<h3 class="mini">Custom methods & Events</h3>
		<p>Fragments provides interface for defining custom component methods and firing Element events which can be binded via standard addEventListener method.</p>
	</div>

	<div class="column-a2 padded">
		<h3 class="mini">Dynamic imports</h3>
		<p>Fragments can specify modules which must be dynamically loaded before initialization.</p>

		<h3 class="mini">Mixins</h3>
		<p>Fragments and activites can inherit from multiple other fragments or activities.</p>

		<h3 class="mini">Lifecycle</h3>
		<p>Fragments can be paused and resumed. When fragments is removed from parent element then it is paused and all event bindings are removed. Resume and pause methods also propagates to all child fragments.</p>
	</div>

	<div class="clear"></div>

</div>

<div class="column-a1">
	
	<h2 class="huge teal clr-icon clr-text clr-border">{% include icons/communication.svg %} Content providers</h2>
	<p>Content providers represents data modelling layer and in most cases they should be connected to server API.</p>
	<p>MetaJS comes with basic reactive content providers such as <strong>ObservingProvider</strong> which implements deep Object.observe and&nbsp;automaticaly notifies about object changes.</p>

</div>

<div class="column-a2">

	<h2 class="huge red clr-icon clr-text clr-border">{% include icons/split.svg %} Channels</h2>
	<p>MetaJS implements publish / subscribe messaging pattern for simple inter-component communication.</p>
	<p>Channels can be created localy in variable scope or can be registered globaly so any application component can access it.</p>

</div>

<div class="clear"></div>

<div class="claim">
	<p>And all of this in less then <strong>50kB</strong> of code</p>
</div>

<article class="products single slim">

	<ul>

		<li>
			<a href="{{ site.baseurl }}/tutorials/" class="clr-hover">
				<span class="icon">{% include icons/lightbulb.svg %}</span>
				<span class="label">Tutorials</span>
			</a>
		</li>

		<li>
			<a href="{{ site.baseurl }}/components/">
				<span class="icon">{% include icons/components.svg %}</span>
				<span class="label">Components</span>
			</a>
		</li>

	</ul>

	<div class="clear"></div>

</article>
